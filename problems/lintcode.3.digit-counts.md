# 题目描述
计算数字 k 在 0 到 n 中的出现的次数，k 可能是 0~9 的一个值。

# 示例输入
```java
// 输入
1, 1
// 输出
1
-----------
//输入：
1, 12
//输出：
5
```
**解释:**  
在 [0, 1] 中，我们发现 1 出现了 1 次 (1)。   
在 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 中，我们发现 1 出现了 5 次 (1, 10, 11, 12)(注意11中有两个1)。  

# 解题思路
该题若不考虑性能直接遍历[0,n],并且对每个数字的每个位进行判断累加即可。这或许是最简单最直接的解法，但同时它也比较低效，因为这需要O(N*M)的时间复杂度。  
因为这里需要进行判断的数字是一段连续的值，所以我们找某个数字出现的次数可以从每个位去考虑，即对于一个千位数中某个数字出现的次数 = 个位出现的次数 + 十位出现的次数 + 百位出现的次数 + 千位出现的次数，这样一来复杂度就降低到O(M)了,对于该问题性能上便可以接受了。  

经观察可发现如下规律:    
设数字N为ABCD，且A,B,C,D∈[0,9]，则在ABCD中每个位置上出现某数字k的次数为:
1. 当该位置的数字大于k时：(高位数字+1)*10的当前位数-1次幂
2. 当该位置的数字等于k时：高位数字*10的当前位数-1次幂 + 低位数字 + 1
3. 当该位置的数字小于k时：高位数字*10的当前位数-1次幂 

这里举个例子：若在数字ABCD求位置B(百位/第三位)上k的个数:
1. 若 B > k 则为: (A+1) * 10<sup>2</sup>
2. 若 B = k 则为: A * 10<sup>2</sup> + CD + 1
3. 若 B < k 则为: A * 10<sup>2</sup>

这里带入ABCD为1234，其中k为2，则百位上的2应该有A00+CD+1 = 100+34+1=135个。也就是1234中可以分为1000和0234两种情况分别计算，1000情况中百位上的组合为[200~299]组成，一共有100个。0234情况中自然就是[200~234]组成，共有35种情况了。十位和个位可以用类似的方法解决。

**注意点:**  
该解法在 k=0 时会将前导0算进来，比如00CD中的0也将会计算到百位千位中0出现的次数中，这显然是不正确的，所以当k=0时需要对某个位减去 10的当前位数-1次幂 次才行。  
原因示例：求[0,100]中0出现的次数  
个位: 因为 `0 = 0` 所以为 `10 * 1 + 0 + 1 = 11`  
十位：因为 `0 = 0` 所以为 `1 * 10 + 0 +1 = 11`    
百位：因为 `1 > 0` 所以为 `(0 + 1) * 100 = 100`    
这里可以明显看出十位多计算了10次，百位多计算了100次0出现的次数，同时我们可以看出是否多计算了0与之前的`< = >`三种情况并无直接关系，只要是非个位，都会进行这种多余的计算，所以我们需要对每个非个位减去10的当前位数次幂才行。

代码可参考：  
[DigitCounts](https://github.com/PAPW/PAPForJava/blob/master/solution/DigitCounts.java)

# 题目来源  
[LintCode 3: DigitCounts](https://www.lintcode.com/problem/digit-counts/description)  