# 题目描述
水仙花数的定义是，这个数等于他每一位数的幂次之和，这个幂等于该数的数位。以下将这个概念简称为位幂和。
比如一个3位的十进制整数153就是一个水仙花数。因为 153 = 1<sup>3</sup> + 5<sup>3</sup>+ 3<sup>3</sup>。
而一个4位的十进制数1634也是一个水仙花数，因为 1634 = 1<sup>4</sup> + 6<sup>4</sup> + 3<sup>4</sup> + 4<sup>4</sup>。
给出n，找到所有的n位十进制水仙花数。

比如 n = 1, 所有水仙花数为：[0,1,2,3,4,5,6,7,8,9]。
而对于 n = 2, 则没有2位的水仙花数，返回 []。
# 示例输入
```java
1
-----
2
-----
3
```
# 示例输出
```java
[0,1,2,3,4,5,6,7,8,9]
-----
[]
-----
[153, 370, 371, 407]
```

# 解题思路
水仙花数是一种比较巧妙的组合，它们的位幂和等于本身，在题目中由入参固定了水仙花数的数位`n`，所以最直接的想法便是通过遍历该数位的所有数字，分别取其每个数位的数字进行幂运算并且相加，看是否等于本身，若等于本身则添加到结果集合中。

**优化点1:**  
由水仙花的特征可知，它的数位越多注定占比越少，而我们计算每一个水仙花数时满足一定的递增性，所以很明显，当计算位幂和时若计算一半时它便大于数字本身了，那么即可以断定，该数字必然不是水仙花数。这样一来便可以省下不少计算量。(3位数时省了大约20%，位数越多越明显)

**优化点2:**
在程序计算中，我们经常需要用到JAVA函数库自带的幂运算函数，该函数的声明是`Math.pow(double,double)`，从这里可以看出既是我们传入的是`int`但在该函数内实际上是两个`double`的计算，这是其一。我们的程序中计算的幂范围比较小，且经常重复，这是其二。在这种情况下我们预先计算所需要的幂运算表不就又可以节省大量运算了吗？
优化是积少成多的，通过该优化使我计算9位水仙花数时候从原来的130s变成了5s，从这可以看出频繁的浮点数计算是多么的消耗性能，缓存是多么的重要。
需要注意的是，小心计算越界。在9位以下时使用`int`类型是没问题的。

代码可参考：[narcissistic-number](https://github.com/PAPW/PAPForJava/blob/master/solution/narcissistic-number.java)

# 题目来源
[LintCode 147: Narcissistic Number](https://www.lintcode.com/problem/narcissistic-number/)